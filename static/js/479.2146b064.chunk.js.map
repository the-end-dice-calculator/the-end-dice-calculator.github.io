{"version":3,"file":"static/js/479.2146b064.chunk.js","mappings":"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","sources":["StatsBlock/math/utils.js","StatsBlock/math/attacker_odds.js","StatsBlock/math/defender_odds.js","StatsBlock/math/calculate_odds.js","StatsBlock/calculate_odds_worker.js"],"sourcesContent":["const clone = (obj, overrides={}) => ({\n\t...obj,\n\t...overrides\n});\n\nfunction* generate_all_rolls(n) {\n\tconst baseline = [[1],[2],[3],[4],[5],[6]];\n\tif (n <= 0) {\n\t\treturn [];\n\t} else if (n === 1) {\n\t\tyield* baseline;\n\t} else {\n\t\tfor (let roll of generate_all_rolls(n - 1)) {\n\t\t\tyield* baseline.map(new_roll => new_roll.concat(roll))\n\t\t}\n\t}\n}\n\n\nconst powers_of_six =\n\t[6**0, 6**1, 6**2, 6**3, 6**4, 6**5, 6**6, 6**7, 6**8, 6**9, 6**10];\nconst vector_sanity_check = (denom, v) => {\n\tconst is_close = (x,y) => Math.abs(x - y) < 0.1;\n\tfor (let power of powers_of_six) {\n\t\tif (is_close(denom, power)) {\n\t\t\treturn;\n\t\t}\n\t}\n\tconsole.error(`Sanity check failed, normalize denom is ${denom}. Expected a power of six between 1 and 6^10.`);\n\tconsole.error(v);\n}\n\nconst normalize_vector = (v) => {\n\tconst denom = Object.values(v).reduce((x,y) => x + y, 0);\n\tvector_sanity_check(denom, v);\n\tconst normalized = Object.fromEntries(\n\t\tObject.entries(v).map(([key, value]) => [key, value / denom])\n\t);\n\treturn normalized;\n}\n\nexport {clone, generate_all_rolls, normalize_vector}\n","import {clone, generate_all_rolls, normalize_vector} from './utils';\n\n// TODO: maybe move these into an array utils file?\n// probably going to use them again\nconst count = (arr, el) => arr.map((x) => x === el).filter(Boolean).length;\nconst indicesOf = (arr, el) =>\n\tarr.map((x, i) => x === el ? i : null).filter((i) => i != null);\n\nconst get_attack_dice = (circumstances) => \n\t1 + circumstances.injuries +\n\t\t(circumstances.long_shot ? 1 : 0) +\n\t\t(circumstances.moving? 1 : 0) +\n\t\t(circumstances.cover ? 1 : 0) +\n\t\t(circumstances.target_running? 1 : 0);\n\nfunction* get_reroll_possibilities (roll, reroll_indices) {\n\tconst rerolls = generate_all_rolls(reroll_indices.length);\n\tfor (let reroll of rerolls) {\n\t\tyield roll.map((x,i) =>\n\t\t\treroll_indices.includes(i) ? reroll[reroll_indices.indexOf(i)] : x)\n\t}\n}\n\nconst get_brutal_reroll_index = (roll, rerolls_used) => {\n\tconst one_indices = indicesOf(roll, 1);\n\tconst two_indices = indicesOf(roll, 2);\n\tfor (let index of one_indices.concat(two_indices)) {\n\t\tif (!rerolls_used.includes(index)) {\n\t\t\treturn index;\n\t\t}\n\t}\n\treturn -1;\n}\n\nconst get_attack_outcome = (roll, is_brutal) => {\n\tif (Math.min(...roll) < 3) {\n\t\treturn \"MISS\";\n\t} else if (Math.min(...roll) < 6) {\n\t\treturn is_brutal ? \"BRUTAL_HIT\" : \"HIT\";\n\t} else {\n\t\treturn is_brutal ? \"BRUTAL_CRIT\" : \"CRIT\";\n\t}\n}\n\nconst generate_attacker_odds = (circumstances) => {\n\tconst outcomes = {\n\t\tBRUTAL_CRIT: 0,\n\t\tCRIT: 0,\n\t\tBRUTAL_HIT: 0,\n\t\tHIT: 0,\n\t\tMISS: 0\n\t}\n\n\tconst evaluate_roll = (\n\t\tcircumstances,\n\t\troll,\n\t\tdice_modified=false,\n\t\trerolls_used=[],\n\t\tweight=1\n\t) => {\n\t\tif (circumstances.rapid_fire) {\n\t\t\tconst reroll_indices =\n\t\t\t\tindicesOf(roll, 1).filter((i) => !rerolls_used.includes(i));\n\t\t\tif (reroll_indices.length) {\n\t\t\t\tconst weight_factor = 1 / (6 ** reroll_indices.length);\n\t\t\t\tfor (let reroll of get_reroll_possibilities(roll, reroll_indices)) {\n\t\t\t\t\tevaluate_roll(\n\t\t\t\t\t\tclone(circumstances, {rapid_fire: false}),\n\t\t\t\t\t\treroll,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\trerolls_used.concat(reroll_indices),\n\t\t\t\t\t\tweight * weight_factor\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (circumstances.precise && count(roll, 2) === 1 && count(roll, 1) === 0) {\n\t\t\tcircumstances = clone(circumstances, {precise: false});\n\t\t\troll[roll.indexOf(2)] += 1;\n\t\t\tdice_modified = true;\n\t\t}\n\t\tif (circumstances.brutal && (roll.includes(1) || roll.includes(2))) {\n\t\t\tconst reroll_index = get_brutal_reroll_index(roll, rerolls_used);\n\t\t\tif (reroll_index >= 0) {\n\t\t\t\t[1,2,3,4,5,6].forEach((n) => {\n\t\t\t\t\tconst reroll = roll.map((x,i) => i === reroll_index? n : x);\n\t\t\t\t\tevaluate_roll(\n\t\t\t\t\t\tclone(circumstances, {brutal: false}),\n\t\t\t\t\t\treroll,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\trerolls_used.concat(reroll_index),\n\t\t\t\t\t\tweight /6\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (circumstances.precise &&\n\t\t\t((count(roll, 2) === 1 && count(roll, 1) === 0)\n\t\t\t\t|| (count(roll, 5) === 1 && count(roll, 6) === roll.length -1))\n\t\t) {\n\t\t\tcircumstances = clone(circumstances, {precise: false});\n\t\t\troll[roll.indexOf(Math.min(...roll))] += 1;\n\t\t\tdice_modified = true;\n\t\t}\n\t\tconst outcome = get_attack_outcome(roll,\n\t\t\tcircumstances.brutal && !dice_modified && rerolls_used.length === 0);\n\t\toutcomes[outcome] += weight;\n\t}\n\n\tfor (let roll of generate_all_rolls(get_attack_dice(circumstances))) {\n\t\tevaluate_roll(circumstances, roll);\n\t}\n\treturn normalize_vector(outcomes);\n}\n\nexport {generate_attacker_odds};\n","import {clone, generate_all_rolls, normalize_vector} from './utils';\n\nconst generate_defender_odds = (circumstances) => {\n\tconst results = {\n\t\tCOVER: 0,\n\t\tARMOR: 0,\n\t\tHIT: 0\n\t};\n\n\tconst evaluate_roll = (circumstances, roll) => {\n\t\tlet die_index = 0;\n\t\tif (circumstances.cover) {\n\t\t\t// TODO: cover value should be able to vary (e.g. Northstar Militia)\n\t\t\t//       but I don't want to deal with it yet\n\t\t\tconst cover_value = 5;\n\t\t\tlet cover_roll = roll[die_index++];\n\t\t\tif (circumstances.piercing && cover_roll === cover_value) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tcover_roll -= 1;\n\t\t\t}\n\t\t\tif (circumstances.scoped && cover_roll >= cover_value) {\n\t\t\t\tcircumstances = clone(circumstances, {scoped: false});\n\t\t\t\tcover_roll = roll[die_index++];\n\t\t\t}\n\t\t\tif (circumstances.piercing && cover_roll >= cover_value) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tcover_roll -= 1;\n\t\t\t}\n\t\t\tif (cover_roll >= cover_value) {\n\t\t\t\treturn \"COVER\";\n\t\t\t}\n\t\t}\n\t\tif (circumstances.armor && circumstances.armor < 7) {\n\t\t\tconst armor_value = circumstances.armor;\n\t\t\tlet armor_roll = roll[die_index++];\n\t\t\tif (circumstances.piercing && armor_roll === armor_value) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tarmor_roll -= 1;\n\t\t\t}\n\t\t\tif (circumstances.scoped && armor_roll >= armor_value) {\n\t\t\t\tcircumstances = clone(circumstances, {scoped: false});\n\t\t\t\tarmor_roll = roll[die_index++];\n\t\t\t}\n\t\t\tif (circumstances.piercing && armor_roll >= armor_value) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tarmor_roll -= 1;\n\t\t\t}\n\t\t\tif (armor_roll >= armor_value) {\n\t\t\t\treturn \"ARMOR\";\n\t\t\t}\n\t\t}\n\t\t//hit made it through the gauntlet of saves\n\t\treturn \"HIT\";\n\t}\n\n\t// We never need more than 3 dice\n\tconst defense_rolls = generate_all_rolls(3);\n\tfor (let roll of defense_rolls) {\n\t\tresults[evaluate_roll(circumstances, roll)] += 1;\n\t}\n\treturn normalize_vector(results);\n}\n\nconst generate_defender_brutal_odds = (circumstances) => {\n\tconst results = {\n\t\t\"COVER\": 0, // 2 cover\n\t\t\"ARMOR\": 0, // 1 cover, 1 armor\n\t\t\"DOUBLE_ARMOR\": 0, // 2 armor\n\t\t\"HIT\": 0, // 1 cover, 1 hit\n\t\t\"ARMOR_AND_HIT\": 0, // 1 armor, 1 hit\n\t\t\"DOUBLE_HIT\": 0 // 2 hit\n\t};\n\n\tconst evaluate_roll = (circumstances, roll) => {\n\t\tlet die_index_1 = 0;\n\t\tlet die_index_2 = 1;\n\t\tconst next_index = () => Math.max(die_index_1, die_index_2) + 1;\n\t\tlet saved_one_from_cover = false;\n\t\tif (circumstances.cover) {\n\t\t\t// TODO: cover value should be able to vary (e.g. Northstar Militia)\n\t\t\t//       but I don't want to deal with it yet\n\t\t\tconst cover_value = 5;\n\t\t\tconst cover_dice = [roll[die_index_1], roll[die_index_2]];\n\t\t\tdie_index_1 = next_index();\n\t\t\tdie_index_2 = next_index();\n\t\t\tif (circumstances.piercing && cover_dice.some(x => x === cover_value)) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tconst pierce_index = cover_dice.findIndex(x => x === cover_value);\n\t\t\t\tcover_dice[pierce_index] -= 1;\n\t\t\t}\n\t\t\tif (circumstances.scoped && cover_dice.some(x => x >= cover_value)) {\n\t\t\t\tcircumstances = clone(circumstances, {scoped: false});\n\t\t\t\tconst scoped_reroll_index =\n\t\t\t\t\tcover_dice.findIndex((die) => die >= cover_value);\n\t\t\t\tcover_dice[scoped_reroll_index] = roll[die_index_1];\n\t\t\t\tdie_index_1 = next_index();\n\t\t\t}\n\t\t\tif (circumstances.piercing && cover_dice.some(x => x >= cover_value)) {\n\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\tlet pierce_index = cover_dice.findIndex(x => x === cover_value);\n\t\t\t\tif (pierce_index === -1) {\n\t\t\t\t\tpierce_index = cover_dice.findIndex(x => x >= cover_value);\n\t\t\t\t}\n\t\t\t\tcover_dice[pierce_index] -= 1;\n\t\t\t}\n\t\t\tif (cover_dice.every((die) => die >= cover_value)) {\n\t\t\t\treturn \"COVER\";\n\t\t\t} else if (cover_dice.some((die) => die >= cover_value)) {\n\t\t\t\tsaved_one_from_cover = true;\n\t\t\t}\n\t\t}\n\t\tif (circumstances.armor && circumstances.armor < 7) {\n\t\t\tconst armor_value = circumstances.armor;\n\t\t\tif (saved_one_from_cover) {\n\t\t\t\t// only one hit needs to be saved\n\t\t\t\tlet armor_roll = roll[die_index_1];\n\t\t\t\tdie_index_1 = next_index();\n\t\t\t\tif (circumstances.piercing && armor_roll === armor_value) {\n\t\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\t\tarmor_roll -= 1;\n\t\t\t\t}\n\t\t\t\tif (circumstances.scoped && armor_roll >= armor_value) {\n\t\t\t\t\tcircumstances = clone(circumstances, {scoped: false});\n\t\t\t\t\tarmor_roll = roll[die_index_1];\n\t\t\t\t\tdie_index_1 = next_index();\n\t\t\t\t}\n\t\t\t\tif (circumstances.piercing && armor_roll >= armor_value) {\n\t\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\t\tarmor_roll -= 1;\n\t\t\t\t}\n\t\t\t\tif (armor_roll >= armor_value) {\n\t\t\t\t\treturn \"ARMOR\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"HIT\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst armor_dice = [roll[die_index_1], roll[die_index_2]];\n\t\t\t\tdie_index_1 = next_index();\n\t\t\t\tdie_index_2 = next_index();\n\t\t\t\tif (circumstances.piercing && \n\t\t\t\t\tarmor_dice.some(x => x === armor_value)\n\t\t\t\t) {\n\t\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\t\tconst pierce_index = armor_dice.findIndex(x => x === armor_value);\n\t\t\t\t\tarmor_dice[pierce_index] -= 1;\n\t\t\t\t}\n\t\t\t\tif (circumstances.scoped &&\n\t\t\t\t\tarmor_dice.some(x => x >= armor_value)\n\t\t\t\t) {\n\t\t\t\t\tcircumstances = clone(circumstances, {scoped: false});\n\t\t\t\t\tconst scoped_reroll_index =\n\t\t\t\t\t\tarmor_dice.findIndex((die) => die >= armor_value);\n\t\t\t\t\tarmor_dice[scoped_reroll_index] = roll[die_index_1];\n\t\t\t\t\tdie_index_1 = next_index();\n\t\t\t\t}\n\t\t\t\tif (circumstances.piercing && \n\t\t\t\t\tarmor_dice.some(x => x >= armor_value)\n\t\t\t\t) {\n\t\t\t\t\tcircumstances = clone(circumstances, {piercing: false});\n\t\t\t\t\tlet pierce_index = armor_dice.findIndex(x => x === armor_value);\n\t\t\t\t\tif (pierce_index === -1) {\n\t\t\t\t\t\tpierce_index = armor_dice.findIndex(x => x >= armor_value);\n\t\t\t\t\t}\n\t\t\t\t\tarmor_dice[pierce_index] -= 1;\n\t\t\t\t}\n\t\t\t\tif (armor_dice.every((die) => die >= armor_value)) {\n\t\t\t\t\treturn \"DOUBLE_ARMOR\";\n\t\t\t\t} else if (armor_dice.some((die) => die >= armor_value)) {\n\t\t\t\t\treturn \"ARMOR_AND_HIT\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"DOUBLE_HIT\";\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// no armor save\n\t\t\tif (saved_one_from_cover) {\n\t\t\t\treturn \"HIT\";\n\t\t\t} else {\n\t\t\t\treturn \"DOUBLE_HIT\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// We never need more than 5 dice\n\tconst defense_rolls = generate_all_rolls(5);\n\tfor (let roll of defense_rolls) {\n\t\tresults[evaluate_roll(circumstances, roll)] += 1;\n\t}\n\treturn normalize_vector(results);\n}\n\nexport {generate_defender_odds, generate_defender_brutal_odds};\n","import {generate_attacker_odds} from './attacker_odds';\nimport {clone} from './utils';\nimport {\n\tgenerate_defender_odds,\n\tgenerate_defender_brutal_odds\n} from './defender_odds';\n\nconst combine_odds = (attack, defense, crit_defense) => {\n\treturn {\n\t\tKILL: attack[\"CRIT\"] * crit_defense[\"HIT\"],\n\t\tHIT: attack[\"HIT\"] * defense[\"HIT\"],\n\t\tARMOR_BREAK:\n\t\t\tattack[\"HIT\"] * defense[\"ARMOR\"] +\n\t\t\tattack[\"CRIT\"] * crit_defense[\"ARMOR\"],\n\t\tMISS: attack[\"MISS\"] + attack[\"HIT\"] * defense[\"COVER\"]\n\t}\n}\n\nconst combine_brutal_odds = (\n\tattack,\n\tdefense,\n\tcrit_defense,\n\tbrutal_defense,\n\tcrit_brutal_defense\n) => {\n\treturn {\n\t\tKILL:\n\t\t\tattack[\"BRUTAL_CRIT\"] * crit_brutal_defense[\"DOUBLE_HIT\"] +\n\t\t\tattack[\"BRUTAL_CRIT\"] * crit_brutal_defense[\"ARMOR_AND_HIT\"] +\n\t\t\tattack[\"CRIT\"] * crit_defense[\"HIT\"],\n\t\tBRUTAL_HIT: attack[\"BRUTAL_HIT\"] * brutal_defense[\"DOUBLE_HIT\"],\n\t\tHIT:\n\t\t\tattack[\"HIT\"] * defense[\"HIT\"] +\n\t\t\tattack[\"BRUTAL_HIT\"] * brutal_defense[\"HIT\"],\n\t\tHIT_AND_ARMOR_BREAK: attack[\"BRUTAL_HIT\"] * brutal_defense[\"ARMOR_AND_HIT\"],\n\t\tARMOR_BREAK:\n\t\t\tattack[\"HIT\"] * defense[\"ARMOR\"] +\n\t\t\tattack[\"CRIT\"] * crit_defense[\"ARMOR\"] +\n\t\t\tattack[\"BRUTAL_HIT\"] * brutal_defense[\"ARMOR\"],\n\t\tDOUBLE_ARMOR_BREAK:\n\t\t\tattack[\"BRUTAL_HIT\"] * brutal_defense[\"DOUBLE_ARMOR\"] +\n\t\t\tattack[\"BRUTAL_CRIT\"] * crit_brutal_defense[\"DOUBLE_ARMOR\"],\n\t\tMISS:\n\t\t\tattack[\"MISS\"] +\n\t\t\tattack[\"HIT\"] * defense[\"COVER\"] +\n\t\t\tattack[\"BRUTAL_HIT\"] * brutal_defense[\"COVER\"]\n\t};\n\n}\n\nconst calculate_brutal_odds = (circumstances) => {\n\tconst attacker_odds = generate_attacker_odds(circumstances);\n\tconst defender_odds = generate_defender_odds(circumstances);\n\tconst defender_crit_odds = circumstances.cover ?\n\t\tgenerate_defender_odds(clone(circumstances, {cover: false})) :\n\t\tdefender_odds;\n\tconst defender_brutal_odds = generate_defender_brutal_odds(circumstances);\n\tconst defender_brutal_crit_odds = circumstances.cover ?\n\t\tgenerate_defender_brutal_odds(clone(circumstances, {cover: false})) :\n\t\tdefender_brutal_odds;\n\treturn combine_brutal_odds(\n\t\tattacker_odds,\n\t\tdefender_odds,\n\t\tdefender_crit_odds,\n\t\tdefender_brutal_odds,\n\t\tdefender_brutal_crit_odds\n\t);\n}\n\nconst calculate_normal_odds = (circumstances) => {\n\tconst attacker_odds = generate_attacker_odds(circumstances);\n\tconst defender_odds = generate_defender_odds(circumstances);\n\tconst defender_crit_odds = circumstances.cover ?\n\t\tgenerate_defender_odds(clone(circumstances, {cover: false})) :\n\t\tdefender_odds;\n\treturn combine_odds(\n\t\tattacker_odds,\n\t\tdefender_odds,\n\t\tdefender_crit_odds,\n\t);\n}\n\nconst calculate_odds = (circumstances) => {\n\tif (circumstances.brutal) {\n\t\treturn calculate_brutal_odds(circumstances);\t\n\t} else {\n\t\treturn calculate_normal_odds(circumstances);\n\t}\n}\n\nexport {calculate_odds};\n","import {calculate_odds} from './math/calculate_odds';\n\nonmessage = function(event)  {\n\tconst odds = calculate_odds(event.data.circumstances);\n\tpostMessage({\n\t\trequestTime: event.data.requestTime,\n\t\toutput: odds\n\t});\n}\n"],"names":["clone","obj","arguments","length","undefined","generate_all_rolls","n","baseline","roll","map","new_roll","concat","powers_of_six","normalize_vector","v","denom","Object","values","reduce","x","y","vector_sanity_check","power","Math","abs","is_close","console","error","fromEntries","entries","_ref","key","value","count","arr","el","filter","Boolean","indicesOf","i","generate_attacker_odds","circumstances","outcomes","BRUTAL_CRIT","CRIT","BRUTAL_HIT","HIT","MISS","evaluate_roll","dice_modified","rerolls_used","weight","rapid_fire","reroll_indices","includes","weight_factor","reroll","rerolls","indexOf","get_reroll_possibilities","precise","brutal","reroll_index","get_brutal_reroll_index","one_indices","two_indices","index","forEach","min","outcome","get_attack_outcome","is_brutal","injuries","long_shot","moving","cover","target_running","get_attack_dice","generate_defender_odds","results","COVER","ARMOR","die_index","cover_value","cover_roll","piercing","scoped","armor","armor_value","armor_roll","defense_rolls","generate_defender_brutal_odds","die_index_1","die_index_2","next_index","max","saved_one_from_cover","cover_dice","some","pierce_index","findIndex","scoped_reroll_index","die","every","armor_dice","calculate_odds","attacker_odds","defender_odds","defender_crit_odds","defender_brutal_odds","defender_brutal_crit_odds","defense","crit_defense","brutal_defense","crit_brutal_defense","KILL","attack","HIT_AND_ARMOR_BREAK","ARMOR_BREAK","DOUBLE_ARMOR_BREAK","combine_brutal_odds","calculate_brutal_odds","combine_odds","calculate_normal_odds","onmessage","event","odds","data","postMessage","requestTime","output"],"sourceRoot":""}